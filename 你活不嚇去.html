<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>你活不嚇去 — 左側觸控移動修正版</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:"Microsoft JhengHei",Arial,sans-serif;}
  #wrap{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;background:#071017;border:2px solid #111; touch-action:none;}
  #hint{position:absolute;left:10px;top:8px;color:#ddd;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:6px;z-index:80;font-size:13px;}
  #restartBtn{position:absolute;right:10px;top:8px;z-index:80;padding:8px 12px;background:rgba(30,30,30,0.9);color:#fff;border-radius:8px;border:1px solid rgba(255,255,255,0.12);cursor:pointer}
  #centerRestart{display:none;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:100;padding:16px 28px;background:rgba(0,0,0,0.9);color:#fff;border-radius:12px;border:2px solid #fff;font-size:18px;cursor:pointer}
  /* 左側觸控區（透明） */
  #leftTouchArea { position:absolute; left:0; top:0; bottom:0; width:50%; z-index:90; }
  /* 右下按鍵（跳與換彈） */
  #rightControls { position:absolute; right:12px; bottom:12px; z-index:95; display:flex; gap:10px; }
  .ctrlBtn { width:68px; height:68px; border-radius:12px; background:rgba(255,255,255,0.08); color:#fff; display:flex; align-items:center; justify-content:center; font-weight:bold; user-select:none; -webkit-user-select:none; }
  #shootBtn { position:absolute; right:12px; top:12px; z-index:95; width:68px; height:68px; border-radius:12px; background:rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:center; font-weight:bold; color:#fff; }
  @media (max-width:520px){
    .ctrlBtn{ width:56px; height:56px; font-size:16px; border-radius:10px; }
    #shootBtn{ width:56px; height:56px; }
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gameCanvas" width="960" height="540"></canvas>
  <div id="hint">左側觸摸控制左右移動 • 右上射擊(長按) • 右下跳/換彈</div>
  <button id="restartBtn">重新一局</button>
  <button id="centerRestart">重新開始</button>

  <!-- 左側整區域為移動觸控區 -->
  <div id="leftTouchArea"></div>

  <!-- 右側按鍵 -->
  <div id="rightControls">
    <div class="ctrlBtn" id="reloadBtn">彈</div>
    <div class="ctrlBtn" id="jumpBtn">↑</div>
  </div>
  <div id="shootBtn" class="ctrlBtn">射</div>
</div>

<script>
/* ======================================================================
   完整遊戲 — 左側觸控移動修正版
   功能：保留所有特效、ammo.png、平台多樣化、鏡頭置中、手機＋桌面可玩
   特別：左側整區為移動控制（觸摸或滑動即可左右）
   ====================================================================== */

/* ---------- Canvas & scale ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const BASE_W = canvas.width, BASE_H = canvas.height;

function fitCanvas(){
  const vw = window.innerWidth, vh = window.innerHeight;
  const scale = Math.min(vw/BASE_W, vh/BASE_H);
  canvas.style.width = Math.floor(BASE_W * scale) + 'px';
  canvas.style.height = Math.floor(BASE_H * scale) + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

/* ---------- Assets ---------- */
const assets = {
  player: { src:'player.png', img:new Image(), loaded:false },
  ammo: { src:'ammo.png', img:new Image(), loaded:false }
};
assets.player.img.onload = ()=> assets.player.loaded = true;
assets.player.img.onerror = ()=> assets.player.loaded = false;
assets.player.img.src = assets.player.src;
assets.ammo.img.onload = ()=> assets.ammo.loaded = true;
assets.ammo.img.onerror = ()=> assets.ammo.loaded = false;
assets.ammo.img.src = assets.ammo.src;

/* ---------- Game state ---------- */
let player = { x:150, y:360, w:36, h:52, dy:0, speed:3.6, jumpPower:-12, jump:false, bullets:30, facing:1, meat:0 };
const gravity = 0.85;
let cameraX = 0, cameraY = 0;
let gameOver = false;
let startTime = Date.now();
let score = 0;

/* torch */
const TORCH_BASE = 10000, TORCH_MAX = 30000;
let torchRemaining = TORCH_BASE;
let lastTick = Date.now();

/* world containers */
let grounds = [{ x:-2000, y:450, w:60000, h:90 }];
let platforms = [];
let torches = [{ x:300, y:380, w:12, h:28 }];
let monsters = [];
let animals = [];
let bullets = [];
let boxes = [];
let particles = [];

const CHUNK_WIDTH = 800;
let generatedLeftMost = -CHUNK_WIDTH;
let generatedRightMost = 2200;

const MAX_ANIMALS_ON_SCREEN = 4;
const MAX_MONSTERS = 18;
let lastMonsterTime = 0;
let lastTickTime = Date.now();

/* ---------- Controls ---------- */
let keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

const leftArea = document.getElementById('leftTouchArea');
const btnJump = document.getElementById('jumpBtn');
const btnReload = document.getElementById('reloadBtn');
const btnShoot = document.getElementById('shootBtn');
const restartBtn = document.getElementById('restartBtn');
const centerRestart = document.getElementById('centerRestart');

restartBtn.addEventListener('click', ()=> restartGame());
centerRestart.addEventListener('click', ()=> restartGame());

/* Touch state for left area movement */
let moveTouchId = null;
let moveTouchX = null; // current touch x
let moveDirection = 0; // -1 left, 0 none, 1 right

/* Bind left area touch: touchstart sets control, touchmove updates, touchend clears */
leftArea.addEventListener('touchstart', function(e){
  e.preventDefault();
  const t = e.changedTouches[0];
  moveTouchId = t.identifier;
  moveTouchX = t.clientX;
  updateMoveDirectionFromTouch(t.clientX);
}, { passive:false });

leftArea.addEventListener('touchmove', function(e){
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier === moveTouchId){
      moveTouchX = t.clientX;
      updateMoveDirectionFromTouch(t.clientX);
      break;
    }
  }
}, { passive:false });

leftArea.addEventListener('touchend', function(e){
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier === moveTouchId){
      moveTouchId = null;
      moveTouchX = null;
      moveDirection = 0;
      break;
    }
  }
}, { passive:false });

/* Support mouse for left area (desktop) */
leftArea.addEventListener('mousedown', function(e){
  e.preventDefault();
  moveTouchId = 'mouse';
  moveTouchX = e.clientX;
  updateMoveDirectionFromTouch(e.clientX);
});
window.addEventListener('mousemove', function(e){
  if(moveTouchId === 'mouse'){
    moveTouchX = e.clientX;
    updateMoveDirectionFromTouch(e.clientX);
  }
});
window.addEventListener('mouseup', function(e){
  if(moveTouchId === 'mouse'){
    moveTouchId = null;
    moveTouchX = null;
    moveDirection = 0;
  }
});

/* Calculate direction from touch X — relative to left half center */
function updateMoveDirectionFromTouch(clientX){
  // get left half bounding box center X in client coords
  const rect = canvas.getBoundingClientRect();
  // left half area spans from rect.left to rect.left + rect.width/2
  const leftHalfLeft = rect.left;
  const leftHalfRight = rect.left + rect.width/2;
  const leftHalfCenter = (leftHalfLeft + leftHalfRight) / 2;
  // If touch outside left half (rare), clamp into left half
  const x = Math.max(leftHalfLeft, Math.min(clientX, leftHalfRight));
  // direction: x < center -> left, x > center -> right
  if(x < leftHalfCenter - 6) moveDirection = -1;
  else if(x > leftHalfCenter + 6) moveDirection = 1;
  else moveDirection = 0;
}

/* Right-side controls: jump, reload, shoot (touch and mouse) */
function bindSimpleBtn(el, onStart, onEnd){
  el.addEventListener('touchstart', e=>{ e.preventDefault(); onStart(); }, { passive:false });
  el.addEventListener('touchend', e=>{ e.preventDefault(); onEnd(); }, { passive:false });
  el.addEventListener('mousedown', e=>{ e.preventDefault(); onStart(); });
  el.addEventListener('mouseup', e=>{ e.preventDefault(); onEnd(); });
  el.addEventListener('mouseleave', e=>{ e.preventDefault(); onEnd(); });
}
bindSimpleBtn(btnJump, ()=> { /* short press jump */ if(!player.jump){ player.dy = player.jumpPower; player.jump = true; } }, ()=>{});
bindSimpleBtn(btnReload, ()=> { player.bullets = 30; }, ()=>{});
/* shoot: long-press for continuous shooting */
let shootPressed = false;
bindSimpleBtn(btnShoot, ()=> { shootPressed = true; }, ()=> { shootPressed = false; });

/* ---------- Platform generation (more types) ---------- */
function generateChunk(chunkX){
  const platformCount = 4 + Math.floor(Math.random()*5);
  const guaranteedIndex = Math.floor(Math.random()*platformCount);
  for(let i=0;i<platformCount;i++){
    const px = chunkX + Math.random()*(CHUNK_WIDTH - 120);
    const py = (i === guaranteedIndex) ? 220 + Math.random()*60 : 160 + Math.random()*160;
    const r = Math.random();
    let movingType = 'static';
    if(r < 0.28) movingType = 'horizontal';
    else if(r < 0.56) movingType = 'vertical';
    else if(r < 0.72) movingType = 'both';
    else if(r < 0.85) movingType = 'diagonal';
    const range = 30 + Math.random()*80;
    const speed = 0.6 + Math.random()*0.9;
    platforms.push({ x: px, y: py, w: 100 + Math.random()*40, h:10, baseX: px, baseY: py, movingType, range, dirX:1, dirY:1, speed });
  }
  if(Math.random() < 0.5) torches.push({ x: chunkX + 100 + Math.random()*600, y: 260 + Math.random()*60, w:12, h:28 });
  if(Math.random() < 0.32) boxes.push({ x: chunkX + 200 + Math.random()*400, y: 240, w:24, h:24, isAmmo:true });
}
for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);

/* ---------- Particle helpers ---------- */
function emitParticle(x,y,vx,vy,life,size,color){
  particles.push({ x,y,vx,vy,life,born:Date.now(),size,color });
}
function emitFlame(x,y,amount=6){
  for(let i=0;i<amount;i++){
    emitParticle(x + (Math.random()-0.5)*8, y + (Math.random()-0.5)*8, (Math.random()-0.5)*1.2, -(0.6 + Math.random()*1.6), 500 + Math.random()*600, 2 + Math.random()*3, '255,120,30');
  }
}

/* ---------- Spawn ---------- */
function spawnMonster(){
  if(monsters.length >= MAX_MONSTERS) return;
  const sx = player.x + (Math.random() < 0.5 ? -520 : 520);
  monsters.push({ x: sx, y: 260, w:40, h:50, dy:0, hp:5 });
}
function spawnAnimal(){
  if(animals.length >= MAX_ANIMALS_ON_SCREEN) return;
  const sx = player.x + (Math.random() < 0.5 ? -320 : 320) + Math.random()*220;
  const sy = player.y - 120 - Math.random()*60;
  animals.push({ x: sx, y: sy, w:28 + Math.random()*6, h:28 + Math.random()*4, dy:0, speed:0.9 + Math.random()*1.0, hp:1 });
}

/* ---------- Shooting ---------- */
function shoot(){
  if(player.bullets <= 0) return;
  const sx = player.x + player.w/2 + (player.facing===1 ? 16 : -16);
  const sy = player.y + player.h/2 - 4;
  bullets.push({ x:sx, y:sy, w:10, h:4, speed:10 * player.facing, born:Date.now() });
  player.bullets--;
  // muzzle
  for(let i=0;i<4;i++){
    emitParticle(sx + (player.facing===1?4:-4), sy + (Math.random()-0.5)*4, (Math.random()-0.5)*1.2 + (player.facing===1?2:-2), (Math.random()-0.5)*1.2, 220 + Math.random()*120, 2 + Math.random()*2, '255,220,100');
  }
}

/* ---------- Update ---------- */
function update(){
  if(gameOver) return;
  const now = Date.now();
  const dt = now - lastTick; lastTick = now;
  torchRemaining -= dt; if(torchRemaining < 0) torchRemaining = 0;

  // dynamic chunk generation
  if(player.x - CHUNK_WIDTH < generatedLeftMost){
    generatedLeftMost -= CHUNK_WIDTH; generateChunk(generatedLeftMost);
  }
  if(player.x + CHUNK_WIDTH > generatedRightMost){
    generateChunk(generatedRightMost + CHUNK_WIDTH); generatedRightMost += CHUNK_WIDTH;
  }

  // Controls: keyboard OR left-area touch movement
  if(keys['a'] || keys['A'] || moveDirection === -1) { player.x -= player.speed; player.facing = -1; }
  if(keys['d'] || keys['D'] || moveDirection === 1) { player.x += player.speed; player.facing = 1; }

  // Jump via keyboard
  if((keys['w'] || keys['W'] || keys['ArrowUp']) && !player.jump){
    player.dy = player.jumpPower; player.jump = true;
    keys['w'] = false; keys['W'] = false; keys['ArrowUp'] = false;
  }

  // touch shoot continuous
  if(shootPressed) {
    if(!shootPressed._last || now - shootPressed._last > 160){ shoot(); shootPressed._last = now; }
  }

  // keyboard shoot (space) single-shot
  if(keys[' ']){ shoot(); keys[' '] = false; }

  // reload keys
  if(keys['r'] || keys['R']){ player.bullets = 30; keys['r'] = false; keys['R'] = false; }

  // physics
  player.dy += gravity; player.y += player.dy;

  // platform movement
  platforms.forEach(p => {
    if(p.movingType === 'horizontal') p.x += p.dirX * p.speed;
    else if(p.movingType === 'vertical') p.y += p.dirY * p.speed;
    else if(p.movingType === 'both' || p.movingType === 'diagonal'){ p.x += p.dirX * p.speed; p.y += p.dirY * p.speed; }
    if(Math.abs(p.x - p.baseX) > p.range) p.dirX *= -1;
    if(Math.abs(p.y - p.baseY) > p.range) p.dirY *= -1;
  });

  // follow platform movement if standing on it
  platforms.forEach(p => {
    if(Math.abs((player.y + player.h) - p.y) <= 4 && player.x + player.w > p.x && player.x < p.x + p.w){
      if(p.movingType === 'horizontal' || p.movingType === 'both' || p.movingType === 'diagonal') player.x += p.dirX * p.speed;
      if(p.movingType === 'vertical' || p.movingType === 'both' || p.movingType === 'diagonal') player.y += p.dirY * p.speed;
    }
  });

  // collisions with ground & platforms
  grounds.concat(platforms).forEach(g => {
    if(player.dy >= -3 &&
       player.y + player.h > g.y - 6 &&
       player.y + player.h < g.y + g.h &&
       player.x + player.w > g.x &&
       player.x < g.x + g.w){
      player.y = g.y - player.h; player.dy = 0; player.jump = false;
    }
  });

  // fall death
  if(player.y > BASE_H + 400) triggerGameOver();

  // spawn logic (increase slightly)
  if(now - lastMonsterTime > 700 + Math.random()*500){
    if(Math.random() < 0.8) spawnMonster();
    if(Math.random() < 0.35) spawnAnimal();
    if(Math.random() < 0.25 && monsters.length < MAX_MONSTERS) spawnMonster();
    lastMonsterTime = now;
  }

  // monsters AI
  monsters.forEach((m,mi) => {
    const dx = player.x - m.x;
    if(Math.abs(dx) > 1) m.x += Math.sign(dx) * 0.75;
    m.dy += gravity; m.y += m.dy;
    grounds.concat(platforms).forEach(g => {
      if(m.y + m.h >= g.y && m.y + m.h <= g.y + g.h && m.x + m.w > g.x && m.x < g.x + g.w){
        m.y = g.y - m.h; m.dy = 0;
      }
    });
    if(player.x < m.x + m.w && player.x + player.w > m.x && player.y < m.y + m.h && player.y + player.h > m.y){
      if(player.meat > 0){ player.meat--; monsters.splice(mi,1); } else triggerGameOver();
    }
  });

  // animals
  animals.forEach((a,ai) => {
    const dx = player.x - a.x;
    if(Math.abs(dx) > 1) a.x += Math.sign(dx) * a.speed;
    a.dy += gravity; a.y += a.dy;
    grounds.concat(platforms).forEach(g => {
      if(a.y + a.h >= g.y && a.y + a.h <= g.y + g.h && a.x + a.w > g.x && a.x < g.x + g.w){
        a.y = g.y - a.h; a.dy = 0;
      }
    });
    if(player.x < a.x + a.w && player.x + player.w > a.x && player.y < a.y + a.h && player.y + player.h > a.y){
      if(player.meat < 5) player.meat++;
      animals.splice(ai,1);
    }
  });

  // bullets
  bullets.forEach((b,bi) => {
    b.x += b.speed;
    if(Date.now() - b.born > 3000 || b.x < player.x - 1500 || b.x > player.x + 1500){ bullets.splice(bi,1); return; }
    for(let mi = monsters.length - 1; mi >= 0; mi--){
      const m = monsters[mi];
      if(b.x < m.x + m.w && b.x + b.w > m.x && b.y < m.y + m.h && b.y + b.h > m.y){
        m.hp--; bullets.splice(bi,1);
        if(m.hp <= 0){
          if(Math.random() < 0.7) torches.push({ x: m.x, y: m.y - 18, w:12, h:28 });
          if(Math.random() < 0.85) boxes.push({ x: m.x, y: m.y - 18, w:24, h:24, isAmmo:true });
          if(Math.random() < 0.5 && player.meat < 5) player.meat++;
          monsters.splice(mi,1);
        }
        break;
      }
    }
    for(let ai = animals.length - 1; ai >= 0; ai--){
      const a = animals[ai];
      if(b.x < a.x + a.w && b.x + b.w > a.x && b.y < a.y + a.h && b.y + b.h > a.y){
        bullets.splice(bi,1);
        if(player.meat < 5) player.meat++;
        animals.splice(ai,1);
        break;
      }
    }
  });

  // boxes pickup
  boxes.forEach((box,bi) => {
    if(player.x < box.x + box.w && player.x + player.w > box.x && player.y < box.y + box.h && player.y + player.h > box.y){
      player.bullets = 30; boxes.splice(bi,1);
    }
  });

  // torches pickup & particle emit
  torches.forEach((t,ti) => {
    emitFlame(t.x - cameraX + t.w/2, t.y + 6, 2);
    if(player.x < t.x + t.w && player.x + player.w > t.x && player.y < t.y + t.h && player.y + player.h > t.y){
      torchRemaining = Math.min(TORCH_MAX, torchRemaining + TORCH_BASE);
      torches.splice(ti,1);
    }
  });

  // particle update
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.03;
    if(Date.now() - p.born > p.life) particles.splice(i,1);
  }

  if(torchRemaining <= 0) triggerGameOver();

  // score
  score = Math.floor((Date.now() - startTime) / 1000);

  // camera centered on player
  cameraX = player.x - BASE_W/2 + player.w/2;
  cameraY = player.y - BASE_H/2 + player.h/2;
}

/* ---------- Game Over & Restart ---------- */
function triggerGameOver(){
  gameOver = true;
  centerRestart.style.display = 'block';
}
function restartGame(){
  player = { x:150, y:360, w:36, h:52, dy:0, speed:3.6, jumpPower:-12, jump:false, bullets:30, facing:1, meat:0 };
  cameraX = 0; cameraY = 0; gameOver = false; startTime = Date.now(); score = 0; torchRemaining = TORCH_BASE;
  monsters = []; animals = []; bullets = []; boxes = []; particles = []; platforms = []; torches = [{ x:300, y:380, w:12, h:28 }];
  generatedLeftMost = -CHUNK_WIDTH; generatedRightMost = 2200;
  for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);
  centerRestart.style.display = 'none';
}

/* ---------- Draw ---------- */
function draw(){
  ctx.clearRect(0,0,BASE_W,BASE_H);
  ctx.fillStyle = '#071017';
  ctx.fillRect(0,0,BASE_W,BASE_H);

  // world draw with camera offset
  ctx.fillStyle = '#d1b24b';
  grounds.forEach(g => ctx.fillRect(g.x - cameraX, g.y - cameraY, g.w, g.h));

  platforms.forEach(p => { ctx.fillStyle = '#c9a82a'; ctx.fillRect(p.x - cameraX, p.y - cameraY, p.w, p.h); });

  // boxes (ammo)
  boxes.forEach(b => {
    if(b.isAmmo && assets.ammo.loaded){
      ctx.drawImage(assets.ammo.img, b.x - cameraX, b.y - cameraY, b.w, b.h);
    } else {
      ctx.fillStyle = '#7b2fa3'; ctx.fillRect(b.x - cameraX, b.y - cameraY, b.w, b.h);
    }
  });

  // monsters
  monsters.forEach(m => { ctx.fillStyle = '#b83939'; ctx.fillRect(m.x - cameraX, m.y - cameraY, m.w, m.h); });

  // animals
  animals.forEach(a => { ctx.fillStyle = '#ff80c8'; ctx.fillRect(a.x - cameraX, a.y - cameraY, a.w, a.h); });

  // bullets
  bullets.forEach(b => {
    ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = 'rgba(255,255,200,0.9)'; ctx.fillRect(b.x - cameraX - 1, b.y - cameraY - 1, b.w + 2, b.h + 2); ctx.restore();
    ctx.fillStyle = '#fff'; ctx.fillRect(b.x - cameraX, b.y - cameraY, b.w, b.h);
  });

  // particles base
  particles.forEach(p => {
    const lifeRatio = 1 - (Date.now() - p.born) / p.life;
    const alpha = Math.max(0, lifeRatio);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `rgba(${p.color},${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x - cameraX, p.y - cameraY, p.size * (1 + (1-lifeRatio)), 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });

  // torches
  torches.forEach(t => {
    ctx.fillStyle = '#553311'; ctx.fillRect(t.x - cameraX + 4, t.y - cameraY + 18, 4, 10);
    ctx.fillStyle = '#ff8a00'; ctx.fillRect(t.x - cameraX, t.y - cameraY, t.w, t.h);
  });

  // player
  const px = player.x - cameraX, py = player.y - cameraY;
  if(assets.player.loaded) ctx.drawImage(assets.player.img, px, py, player.w, player.h);
  else { ctx.fillStyle = '#fff'; ctx.fillRect(px, py, player.w, player.h); }

  // gun simple
  ctx.fillStyle = '#8b8b8b';
  if(player.facing === 1){ ctx.fillRect(px + player.w - 6, py + 20, 34, 8); ctx.fillRect(px + player.w + 26, py + 18, 6, 12); }
  else { ctx.fillRect(px - 28, py + 20, 34, 8); ctx.fillRect(px - 34, py + 18, 6, 12); }

  // zombie eyes glow
  monsters.forEach(m => {
    ctx.save(); ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,40,40,0.95)'; ctx.shadowColor = 'rgba(255,60,60,0.8)'; ctx.shadowBlur = 12;
    ctx.fillRect(m.x + 8 - cameraX, m.y + 10 - cameraY, 6, 6); ctx.fillRect(m.x + 26 - cameraX, m.y + 10 - cameraY, 6, 6);
    ctx.restore();
  });

  // LIGHTING: overall dim + lighter glow for player and torches
  ctx.fillStyle = 'rgba(0,0,0,0.42)'; ctx.fillRect(0,0,BASE_W,BASE_H);
  ctx.save(); ctx.globalCompositeOperation = 'lighter';
  const playerCenterX = px + player.w/2, playerCenterY = py + player.h/2, playerRadius = 160;
  let pg = ctx.createRadialGradient(playerCenterX, playerCenterY, 0, playerCenterX, playerCenterY, playerRadius);
  pg.addColorStop(0, 'rgba(255,250,200,0.95)'); pg.addColorStop(0.25, 'rgba(255,230,160,0.35)'); pg.addColorStop(1, 'rgba(255,200,120,0)');
  ctx.fillStyle = pg; ctx.beginPath(); ctx.arc(playerCenterX, playerCenterY, playerRadius, 0, Math.PI*2); ctx.fill();
  torches.forEach(t => {
    const tx = t.x - cameraX + t.w/2, ty = t.y - cameraY + 8, r = 110 + Math.sin(Date.now()/150 + t.x)*16;
    let tg = ctx.createRadialGradient(tx, ty, 0, tx, ty, r);
    tg.addColorStop(0, 'rgba(255,200,120,0.95)'); tg.addColorStop(0.35, 'rgba(255,170,90,0.35)'); tg.addColorStop(1, 'rgba(255,140,60,0)');
    ctx.fillStyle = tg; ctx.beginPath(); ctx.arc(tx, ty, r, 0, Math.PI*2); ctx.fill();
  });
  ctx.restore();

  // particle highlight
  ctx.save(); ctx.globalCompositeOperation = 'lighter';
  particles.forEach(p => {
    const lifeRatio = 1 - (Date.now() - p.born) / p.life;
    const alpha = Math.max(0, lifeRatio);
    ctx.fillStyle = `rgba(${p.color},${alpha})`;
    ctx.beginPath(); ctx.arc(p.x - cameraX, p.y - cameraY, p.size * 1.8, 0, Math.PI*2); ctx.fill();
  });
  ctx.restore();

  // HUD
  ctx.fillStyle = '#fff'; ctx.font = '16px Arial';
  ctx.fillText('時間: ' + score + ' 秒', 14, 24);
  ctx.fillText('子彈: ' + player.bullets + '/30', 14, 48);
  ctx.fillText('火把剩餘: ' + (torchRemaining/1000).toFixed(1) + ' 秒', 14, 72);
  ctx.fillText('肉: ' + player.meat + '/5', 14, 96);

  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,BASE_W,BASE_H);
    ctx.fillStyle = '#ff6666'; ctx.font = '40px "Microsoft JhengHei"'; ctx.fillText('遊戲結束！', BASE_W/2 - 110, BASE_H/2 - 10);
    ctx.fillStyle = '#fff'; ctx.font = '20px "Microsoft JhengHei"'; ctx.fillText('點擊「重新開始」重開遊戲', BASE_W/2 - 150, BASE_H/2 + 28);
  }
}

/* ---------- Main loop ---------- */
function loop(){
  // handle touch continuous shooting
  if(shootPressed) {
    const now = Date.now();
    if(!shootPressed._last || now - shootPressed._last > 160){ shoot(); shootPressed._last = now; }
  }
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* ---------- Ensure chunks exist ---------- */
for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);

/* ---------- Display center restart when game over ---------- */
setInterval(()=> { centerRestart.style.display = gameOver ? 'block' : 'none'; }, 200);

/* ---------- Utilities ---------- */
function triggerGameOver(){ gameOver = true; centerRestart.style.display = 'block'; }
function restartGame(){
  player = { x:150, y:360, w:36, h:52, dy:0, speed:3.6, jumpPower:-12, jump:false, bullets:30, facing:1, meat:0 };
  cameraX = 0; cameraY = 0; gameOver = false; startTime = Date.now(); score = 0; torchRemaining = TORCH_BASE;
  monsters = []; animals = []; bullets = []; boxes = []; particles = []; platforms = []; torches = [{ x:300, y:380, w:12, h:28 }];
  generatedLeftMost = -CHUNK_WIDTH; generatedRightMost = 2200;
  for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);
  centerRestart.style.display = 'none';
}

/* Expose debug */
window.restartGame = restartGame;
window.setPlayerSize = (w,h)=>{ player.w=w; player.h=h; };

</script>
</body>
</html>

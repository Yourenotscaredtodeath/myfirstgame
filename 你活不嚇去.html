<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>你活不嚇去 — 手機版 (完整)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:"Microsoft JhengHei",Arial,sans-serif;}
  #wrap{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;background:#071017;border:2px solid #111; touch-action:none;}
  /* UI */
  #hint { position:absolute; left:8px; top:8px; z-index:60; color:#ddd; background:rgba(0,0,0,0.35); padding:6px 8px; border-radius:6px; font-size:13px;}
  #restartBtn { position:absolute; right:8px; top:8px; z-index:60; padding:8px 12px; background:rgba(30,30,30,0.9); color:#fff; border-radius:8px; border:1px solid #eee; font-size:14px; }
  #centerRestart { display:none; position:absolute; left:50%; top:52%; transform:translate(-50%,-50%); z-index:80; padding:14px 20px; font-size:18px; border-radius:10px; background:rgba(0,0,0,0.85); color:#fff; border:2px solid #fff; }
  /* Mobile controls */
  .touch-controls { position:absolute; z-index:70; bottom:12px; left:12px; display:flex; gap:8px; align-items:center; }
  .touch-controls-right { position:absolute; z-index:70; bottom:12px; right:12px; display:flex; gap:8px; align-items:center; }
  .btn { width:64px; height:64px; border-radius:12px; background:rgba(255,255,255,0.08); color:#fff; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:18px; user-select:none; -webkit-user-select:none; }
  .btn:active { transform: translateY(2px); background:rgba(255,255,255,0.14); }
  @media (max-width:520px){
    .btn { width:56px; height:56px; font-size:16px; border-radius:10px; }
  }
  /* small note */
  #note { position:absolute; left:50%; transform:translateX(-50%); top:6px; color:#aaa; z-index:50; font-size:12px;}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gameCanvas" width="960" height="540"></canvas>
  <div id="hint">移動: 左右按鈕 或 A/D ，跳: W或↑ 或左下跳鍵，射擊: 空白 或 右側射擊鍵，換彈: R 或 右側換彈</div>
  <button id="restartBtn">重新一局</button>
  <button id="centerRestart">重新開始</button>

  <!-- 手機按鈕（左側移動 + 跳），右側射擊/換彈 -->
  <div class="touch-controls" id="leftControls">
    <div class="btn" id="leftBtn">◀</div>
    <div class="btn" id="rightBtn">▶</div>
    <div class="btn" id="jumpBtn">↑</div>
  </div>
  <div class="touch-controls-right" id="rightControls">
    <div class="btn" id="shootBtn">射</div>
    <div class="btn" id="reloadBtn">彈</div>
  </div>

  <div id="note">手機支援：可長按移動/射擊</div>
</div>

<script>
/* =========================
   完整遊戲 — 手機支援版
   功能：保留所有原本特效、平台多元、ammo.png、觸控按鈕
   使用說明：將 player.png 與 ammo.png 放在同資料夾
   ========================= */

/* ------ Canvas & scaling for mobile ------ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const BASE_W = canvas.width;
const BASE_H = canvas.height;

function fitCanvasToWindow(){
  const wrap = document.getElementById('wrap');
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  // 保持 aspect ratio
  const scale = Math.min(vw/BASE_W, vh/BASE_H);
  canvas.style.width = Math.floor(BASE_W * scale) + 'px';
  canvas.style.height = Math.floor(BASE_H * scale) + 'px';
  // adjust UI positions if needed
}
window.addEventListener('resize', fitCanvasToWindow);
fitCanvasToWindow();

/* ------ Resources (images) ------ */
const resources = {
  player: { src:'player.png', img: new Image(), loaded:false },
  ammo: { src:'ammo.png', img: new Image(), loaded:false }
};
resources.player.img.onload = ()=> resources.player.loaded = true;
resources.player.img.onerror = ()=> resources.player.loaded = false;
resources.player.img.src = resources.player.src;
resources.ammo.img.onload = ()=> resources.ammo.loaded = true;
resources.ammo.img.onerror = ()=> resources.ammo.loaded = false;
resources.ammo.img.src = resources.ammo.src;

/* ------ Game State ------ */
let player = { x:150, y:360, w:36, h:52, dy:0, speed:3.6, jumpPower:-12, jump:false, bullets:30, facing:1, meat:0 };
const gravity = 0.85;
let cameraX = 0, cameraY = 0;
let gameOver = false;
let startTime = Date.now();
let score = 0;

/* Torch timing */
const TORCH_BASE = 10000;
const TORCH_MAX = 30000;
let torchRemaining = TORCH_BASE;
let lastTick = Date.now();

/* World objects */
let grounds = [{ x:-2000, y:450, w:60000, h:90 }];
let platforms = [];
let torches = [{ x:300, y:380, w:12, h:28 }];
let monsters = [];
let animals = [];
let bullets = [];
let boxes = []; // ammo boxes - use ammo.png
let particles = [];

const CHUNK_WIDTH = 800;
let generatedLeftMost = -CHUNK_WIDTH;
let generatedRightMost = 2200;
const MAX_ANIMALS_ON_SCREEN = 4;

/* Input state */
let keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

/* Touch buttons */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const jumpBtn = document.getElementById('jumpBtn');
const shootBtn = document.getElementById('shootBtn');
const reloadBtn = document.getElementById('reloadBtn');
const restartBtn = document.getElementById('restartBtn');
const centerRestart = document.getElementById('centerRestart');

let touchState = { left:false, right:false, jump:false, shoot:false, reload:false };

// add touch events (supports long press)
function bindTouch(btn, onStart, onEnd){
  btn.addEventListener('touchstart', e => { e.preventDefault(); onStart(); }, { passive:false });
  btn.addEventListener('touchend', e => { e.preventDefault(); onEnd(); }, { passive:false });
  btn.addEventListener('mousedown', e => { e.preventDefault(); onStart(); });
  btn.addEventListener('mouseup', e => { e.preventDefault(); onEnd(); });
  btn.addEventListener('mouseleave', e => { e.preventDefault(); onEnd(); });
}
bindTouch(leftBtn, ()=> touchState.left = true, ()=> touchState.left = false);
bindTouch(rightBtn, ()=> touchState.right = true, ()=> touchState.right = false);
bindTouch(jumpBtn, ()=> { touchState.jump = true; setTimeout(()=> touchState.jump = false, 150); }, ()=> {});
bindTouch(shootBtn, ()=> touchState.shoot = true, ()=> touchState.shoot = false);
bindTouch(reloadBtn, ()=> { touchState.reload = true; setTimeout(()=>{ player.bullets = 30; touchState.reload=false; }, 200); }, ()=> touchState.reload = false);

/* Restart */
restartBtn.addEventListener('click', ()=> restartGame());
centerRestart.addEventListener('click', ()=> restartGame());

/* Utility: random int */
function rnd(min,max){ return Math.floor(min + Math.random()*(max-min+1)); }

/* ------ Platform generation (more diverse movement types) ------ */
function generateChunk(chunkX){
  const platformCount = 4 + Math.floor(Math.random()*5);
  const guaranteedIndex = Math.floor(Math.random()*platformCount);
  for(let i=0;i<platformCount;i++){
    const px = chunkX + Math.random()*(CHUNK_WIDTH - 120);
    const py = (i === guaranteedIndex) ? 220 + Math.random()*60 : 160 + Math.random()*160;
    const r = Math.random();
    let movingType = 'static';
    if(r < 0.28) movingType = 'horizontal';
    else if(r < 0.56) movingType = 'vertical';
    else if(r < 0.72) movingType = 'both'; // both axis movement (up/down & left/right)
    else if(r < 0.85) movingType = 'diagonal'; // diagonal movement
    const range = 30 + Math.random()*80;
    platforms.push({ x: px, y: py, w: 100 + Math.random()*40, h: 10, baseX: px, baseY: py, movingType, range, dirX:1, dirY:1, speed: 0.6 + Math.random()*0.9 });
  }
  // add torches and ammo boxes sometimes
  if(Math.random() < 0.5) torches.push({ x: chunkX + 100 + Math.random()*600, y: 260 + Math.random()*60, w:12, h:28 });
  if(Math.random() < 0.32) boxes.push({ x: chunkX + 200 + Math.random()*400, y: 240, w:24, h:24, isAmmo:true });
}
for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);

/* ------ Particles ------ */
function emitParticle(x,y,vx,vy,life,size,color){
  particles.push({ x,y,vx,vy,life,born:Date.now(),size,color });
}
function emitFlame(x,y,amount=6){
  for(let i=0;i<amount;i++){
    emitParticle(x + (Math.random()-0.5)*8, y + (Math.random()-0.5)*8, (Math.random()-0.5)*1.2, -(0.6 + Math.random()*1.6), 500 + Math.random()*600, 2 + Math.random()*3, '255,120,30');
  }
}

/* ------ Spawn functions ------ */
function spawnMonster(){
  const sx = player.x + (Math.random()<0.5 ? -520 : 520);
  monsters.push({ x:sx, y:260, w:40, h:50, dy:0, hp:5 });
}
function spawnAnimal(){
  if(animals.length >= MAX_ANIMALS_ON_SCREEN) return;
  const sx = player.x + (Math.random()<0.5 ? -300 : 300) + Math.random()*220;
  const sy = player.y - 120 - Math.random()*60;
  animals.push({ x:sx, y:sy, w:28 + Math.random()*6, h:28 + Math.random()*6, dy:0, speed:0.9 + Math.random()*1.0, hp:1 });
}

/* ------ Shooting ------ */
function shoot(){
  if(player.bullets <= 0) return;
  const sx = player.x + player.w/2 + (player.facing===1?16:-16);
  const sy = player.y + player.h/2 - 4;
  bullets.push({ x:sx, y:sy, w:10, h:4, speed:10*player.facing, born:Date.now() });
  player.bullets--;
  // muzzle particles
  for(let i=0;i<4;i++){
    emitParticle(sx + (player.facing===1?6:-6), sy + (Math.random()-0.5)*4, (Math.random()-0.5)*1.2 + (player.facing===1?2:-2), (Math.random()-0.5)*1.2, 220 + Math.random()*120, 2 + Math.random()*2, '255,220,100');
  }
}

/* ------ Update loop ------ */
let lastMonsterTime = 0;
function update(){
  if(gameOver) return;

  const now = Date.now();
  const dt = now - lastTick; lastTick = now;
  torchRemaining -= dt; if(torchRemaining < 0) torchRemaining = 0;

  // touch->keys mapping
  if(touchState.left) keys['a'] = true; else if(!keys['ArrowLeft']) keys['a'] = keys['a']; // preserve keyboard if used
  if(touchState.right) keys['d'] = true; else if(!keys['ArrowRight']) keys['d'] = keys['d'];
  if(touchState.shoot) { if(!keys[' ']) keys[' '] = true; } else { if(!touchState.shoot) keys[' '] = keys[' ']; }
  if(touchState.reload) { player.bullets = 30; touchState.reload = false; }

  // apply left/right from either keyboard or touch
  if(keys['a'] || touchState.left){ player.x -= player.speed; player.facing = -1; }
  if(keys['d'] || touchState.right){ player.x += player.speed; player.facing = 1; }
  if((keys['w'] || keys['ArrowUp'] || touchState.jump) && !player.jump){
    player.dy = player.jumpPower; player.jump = true;
  }
  // reset temporary keyboard jump if used
  if(keys['w']) keys['w'] = false;

  // gravity & movement
  player.dy += gravity; player.y += player.dy;

  // platform movement types: horizontal/vertical/both/diagonal/static
  platforms.forEach(p => {
    if(p.movingType === 'horizontal') p.x += p.dirX * p.speed;
    else if(p.movingType === 'vertical') p.y += p.dirY * p.speed;
    else if(p.movingType === 'both'){ p.x += p.dirX * p.speed; p.y += p.dirY * p.speed; }
    else if(p.movingType === 'diagonal'){ p.x += p.dirX * p.speed; p.y += p.dirY * p.speed; }
    // range check
    if(Math.abs(p.x - p.baseX) > p.range) p.dirX *= -1;
    if(Math.abs(p.y - p.baseY) > p.range) p.dirY *= -1;
  });

  // If player stands on moving platform, follow it horizontally and vertically
  platforms.forEach(p=>{
    if(Math.abs((player.y + player.h) - p.y) <= 4 && player.x + player.w > p.x && player.x < p.x + p.w){
      player.x += (p.movingType === 'horizontal' || p.movingType === 'both' || p.movingType === 'diagonal') ? p.dirX * p.speed : 0;
      player.y += (p.movingType === 'vertical' || p.movingType === 'both' || p.movingType === 'diagonal') ? p.dirY * p.speed : 0;
    }
  });

  // collision with ground/platforms
  let onGround = false;
  grounds.concat(platforms).forEach(g => {
    if(player.dy >= -3 && player.y + player.h > g.y - 6 && player.y + player.h < g.y + g.h && player.x + player.w > g.x && player.x < g.x + g.w){
      player.y = g.y - player.h;
      player.dy = 0;
      player.jump = false;
      onGround = true;
    }
  });

  // fall death
  if(player.y > BASE_H + 400) triggerGameOver();

  // spawn logic
  if(now - lastMonsterTime > 900 + Math.random()*600){
    if(Math.random() < 0.6) spawnMonster();
    if(Math.random() < 0.35) spawnAnimal();
    lastMonsterTime = now;
  }

  // monster AI
  monsters.forEach((m,mi) => {
    const dx = player.x - m.x;
    if(Math.abs(dx) > 1) m.x += Math.sign(dx) * 0.72;
    m.dy += gravity; m.y += m.dy;
    grounds.concat(platforms).forEach(g => {
      if(m.y + m.h >= g.y && m.y + m.h <= g.y + g.h && m.x + m.w > g.x && m.x < g.x + g.w){
        m.y = g.y - m.h; m.dy = 0;
      }
    });
    if(player.x < m.x + m.w && player.x + player.w > m.x && player.y < m.y + m.h && player.y + player.h > m.y){
      if(player.meat > 0){ player.meat--; monsters.splice(mi,1); } else triggerGameOver();
    }
  });

  // animals
  animals.forEach((a,ai) => {
    const dx = player.x - a.x;
    if(Math.abs(dx) > 1) a.x += Math.sign(dx) * a.speed;
    a.dy += gravity; a.y += a.dy;
    grounds.concat(platforms).forEach(g=>{
      if(a.y + a.h >= g.y && a.y + a.h <= g.y + g.h && a.x + a.w > g.x && a.x < g.x + g.w){
        a.y = g.y - a.h; a.dy = 0;
      }
    });
    if(player.x < a.x + a.w && player.x + player.w > a.x && player.y < a.y + a.h && player.y + player.h > a.y){
      if(player.meat < 5) player.meat++;
      animals.splice(ai,1);
    }
  });

  // bullets
  bullets.forEach((b,bi) => {
    b.x += b.speed;
    if(Date.now() - b.born > 3000 || b.x < player.x - 1500 || b.x > player.x + 1500) { bullets.splice(bi,1); return; }
    for(let mi = monsters.length - 1; mi >= 0; mi--){
      const m = monsters[mi];
      if(b.x < m.x + m.w && b.x + b.w > m.x && b.y < m.y + m.h && b.y + b.h > m.y){
        m.hp--; bullets.splice(bi,1);
        if(m.hp <= 0){
          if(Math.random() < 0.7) torches.push({ x: m.x, y: m.y - 18, w:12, h:28 });
          if(Math.random() < 0.8) boxes.push({ x: m.x, y: m.y - 18, w:24, h:24, isAmmo:true });
          if(Math.random() < 0.5 && player.meat < 5) player.meat++;
          monsters.splice(mi,1);
        }
        break;
      }
    }
    for(let ai = animals.length - 1; ai >= 0; ai--){
      const a = animals[ai];
      if(b.x < a.x + a.w && b.x + b.w > a.x && b.y < a.y + a.h && b.y + b.h > a.y){
        bullets.splice(bi,1);
        if(player.meat < 5) player.meat++;
        animals.splice(ai,1);
        break;
      }
    }
  });

  // boxes (ammo) pickup
  boxes.forEach((box,bi) => {
    if(player.x < box.x + box.w && player.x + player.w > box.x && player.y < box.y + box.h && player.y + player.h > box.y){
      player.bullets = 30; boxes.splice(bi,1);
    }
  });

  // torches pickup and flame emit
  torches.forEach((t,ti) => {
    emitFlame(t.x - cameraX + t.w/2, t.y + 6, 2);
    if(player.x < t.x + t.w && player.x + player.w > t.x && player.y < t.y + t.h && player.y + player.h > t.y){
      torchRemaining = Math.min(TORCH_MAX, torchRemaining + TORCH_BASE);
      torches.splice(ti,1);
    }
  });

  // particle update
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.03;
    if(Date.now() - p.born > p.life) particles.splice(i,1);
  }

  // torch out -> game over
  if(torchRemaining <= 0) triggerGameOver();

  // score
  score = Math.floor((Date.now() - startTime)/1000);

  // camera center on player (both axes)
  cameraX = player.x - BASE_W/2 + player.w/2;
  cameraY = player.y - BASE_H/2 + player.h/2;
}

/* ------ Game over / restart ------ */
function triggerGameOver(){
  gameOver = true;
  centerRestart.style.display = 'block';
}
function restartGame(){
  player = { x:150, y:360, w:36, h:52, dy:0, speed:3.6, jumpPower:-12, jump:false, bullets:30, facing:1, meat:0 };
  cameraX = 0; cameraY = 0; gameOver = false; startTime = Date.now(); score = 0; torchRemaining = TORCH_BASE;
  monsters = []; animals = []; bullets = []; boxes = []; particles = []; platforms = []; torches = [{ x:300, y:380, w:12, h:28 }];
  generatedLeftMost = -CHUNK_WIDTH; generatedRightMost = 2200;
  for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);
  centerRestart.style.display = 'none';
}

/* ------ Draw ------ */
function draw(){
  // clear
  ctx.clearRect(0,0,BASE_W,BASE_H);

  // background
  ctx.fillStyle = '#071017';
  ctx.fillRect(0,0,BASE_W,BASE_H);

  // translate by camera
  // world coords -> screen coords: (worldX - cameraX, worldY - cameraY)
  // ground
  ctx.fillStyle = '#d1b24b';
  grounds.forEach(g => ctx.fillRect(g.x - cameraX, g.y - cameraY, g.w, g.h));

  // platforms
  platforms.forEach(p => {
    ctx.fillStyle = '#c9a82a';
    ctx.fillRect(p.x - cameraX, p.y - cameraY, p.w, p.h);
  });

  // boxes (ammo) - show image if loaded
  boxes.forEach(b => {
    if(b.isAmmo && resources.ammo.loaded){
      ctx.drawImage(resources.ammo.img, b.x - cameraX, b.y - cameraY, b.w, b.h);
    } else {
      ctx.fillStyle = '#7b2fa3';
      ctx.fillRect(b.x - cameraX, b.y - cameraY, b.w, b.h);
    }
  });

  // monsters
  monsters.forEach(m => {
    ctx.fillStyle = '#b83939';
    ctx.fillRect(m.x - cameraX, m.y - cameraY, m.w, m.h);
  });

  // animals
  animals.forEach(a => {
    ctx.fillStyle = '#ff80c8';
    ctx.fillRect(a.x - cameraX, a.y - cameraY, a.w, a.h);
  });

  // bullets (glow + core)
  bullets.forEach(b => {
    ctx.save(); ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,255,200,0.9)';
    ctx.fillRect(b.x - cameraX - 1, b.y - cameraY - 1, b.w + 2, b.h + 2);
    ctx.restore();
    ctx.fillStyle = '#fff';
    ctx.fillRect(b.x - cameraX, b.y - cameraY, b.w, b.h);
  });

  // particles base
  particles.forEach(p => {
    const lifeRatio = 1 - (Date.now() - p.born)/p.life;
    const alpha = Math.max(0, lifeRatio);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `rgba(${p.color},${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x - cameraX, p.y - cameraY, p.size * (1 + (1-lifeRatio)), 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });

  // torches (physical)
  torches.forEach(t => {
    ctx.fillStyle = '#553311';
    ctx.fillRect(t.x - cameraX + 4, t.y - cameraY + 18, 4, 10);
    ctx.fillStyle = '#ff8a00';
    ctx.fillRect(t.x - cameraX, t.y - cameraY, t.w, t.h);
  });

  // player image or fallback
  const px = player.x - cameraX, py = player.y - cameraY;
  if(resources.player.loaded){
    ctx.drawImage(resources.player.img, px, py, player.w, player.h);
  } else {
    ctx.fillStyle = '#fff';
    ctx.fillRect(px, py, player.w, player.h);
  }

  // gun simple
  ctx.fillStyle = '#8b8b8b';
  if(player.facing === 1){
    ctx.fillRect(px + player.w - 6, py + 20, 34, 8);
    ctx.fillRect(px + player.w + 26, py + 18, 6, 12);
  } else {
    ctx.fillRect(px - 28, py + 20, 34, 8);
    ctx.fillRect(px - 34, py + 18, 6, 12);
  }

  // zombie eyes glow (lighter)
  monsters.forEach(m => {
    ctx.save(); ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,40,40,0.95)';
    ctx.shadowColor = 'rgba(255,60,60,0.8)';
    ctx.shadowBlur = 10;
    ctx.fillRect(m.x + 8 - cameraX, m.y + 10 - cameraY, 6, 6);
    ctx.fillRect(m.x + 26 - cameraX, m.y + 10 - cameraY, 6, 6);
    ctx.restore();
  });

  /* LIGHTING: 先蓋一層微暗罩，然後用 lighter 畫玩家光圈與火把光圈 (使整體微亮、玩家周圍更亮) */
  ctx.fillStyle = 'rgba(0,0,0,0.44)';
  ctx.fillRect(0,0,BASE_W,BASE_H);

  // lighter 光暈
  ctx.save(); ctx.globalCompositeOperation = 'lighter';
  // player glow
  const playerCenterX = px + player.w/2, playerCenterY = py + player.h/2;
  const playerRadius = 160;
  let gp = ctx.createRadialGradient(playerCenterX, playerCenterY, 0, playerCenterX, playerCenterY, playerRadius);
  gp.addColorStop(0, 'rgba(255,250,200,0.95)');
  gp.addColorStop(0.25, 'rgba(255,230,160,0.35)');
  gp.addColorStop(1, 'rgba(255,200,120,0)');
  ctx.fillStyle = gp;
  ctx.beginPath(); ctx.arc(playerCenterX, playerCenterY, playerRadius, 0, Math.PI*2); ctx.fill();

  // torches
  torches.forEach(t => {
    const tx = t.x - cameraX + t.w/2, ty = t.y - cameraY + 8;
    const r = 110 + Math.sin(Date.now()/150 + t.x) * 16;
    let tg = ctx.createRadialGradient(tx, ty, 0, tx, ty, r);
    tg.addColorStop(0, 'rgba(255,200,120,0.95)');
    tg.addColorStop(0.35, 'rgba(255,170,90,0.35)');
    tg.addColorStop(1, 'rgba(255,140,60,0)');
    ctx.fillStyle = tg;
    ctx.beginPath(); ctx.arc(tx, ty, r, 0, Math.PI*2); ctx.fill();
  });
  ctx.restore();

  // particle highlight
  ctx.save(); ctx.globalCompositeOperation = 'lighter';
  particles.forEach(p => {
    const lifeRatio = 1 - (Date.now() - p.born)/p.life;
    const alpha = Math.max(0, lifeRatio);
    ctx.fillStyle = `rgba(${p.color},${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x - cameraX, p.y - cameraY, p.size * 1.6, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.restore();

  // HUD
  ctx.fillStyle = '#fff';
  ctx.font = '16px Arial';
  ctx.fillText('時間: ' + score + ' 秒', 14, 24);
  ctx.fillText('子彈: ' + player.bullets + '/30', 14, 48);
  ctx.fillText('火把剩餘: ' + (torchRemaining/1000).toFixed(1) + ' 秒', 14, 72);
  ctx.fillText('肉: ' + player.meat + '/5', 14, 96);

  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,BASE_W,BASE_H);
    ctx.fillStyle = '#ff6666';
    ctx.font = '40px "Microsoft JhengHei"';
    ctx.fillText('遊戲結束！', BASE_W/2 - 110, BASE_H/2 - 10);
    ctx.fillStyle = '#fff';
    ctx.font = '20px "Microsoft JhengHei"';
    ctx.fillText('點擊「重新開始」重開遊戲', BASE_W/2 - 150, BASE_H/2 + 28);
  }
}

/* ------ Main loop ------ */
function loop(){
  // touch auto-shoot handling (if long press)
  if(touchState.shoot && !keys[' ']) keys[' '] = true;
  // If keyboard space pressed -> perform shot once
  if(keys[' '] && !touchState.shoot){ /* keyboard */ shoot(); keys[' '] = false; }
  // touch shoot will be handled in update (so continuous while pressed)
  update();
  // touch shoot continuous
  if(touchState.shoot) shoot();

  draw();
  requestAnimationFrame(loop);
}
loop();

/* ---------- Helpers & Debug ---------- */
function triggerGameOver(){ gameOver = true; centerRestart.style.display = 'block'; }
function restartGame(){
  player = { x:150, y:360, w:36, h:52, dy:0, speed:3.6, jumpPower:-12, jump:false, bullets:30, facing:1, meat:0 };
  cameraX = 0; cameraY = 0; gameOver = false; startTime = Date.now(); score = 0; torchRemaining = TORCH_BASE;
  monsters = []; animals = []; bullets = []; boxes = []; particles = []; platforms = []; torches = [{ x:300, y:380, w:12, h:28 }];
  generatedLeftMost = -CHUNK_WIDTH; generatedRightMost = 2200;
  for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);
  centerRestart.style.display = 'none';
}

/* make sure initial chunks exist */
platforms = [];
for(let cx = -CHUNK_WIDTH; cx <= generatedRightMost; cx += CHUNK_WIDTH) generateChunk(cx);

/* Adjust canvas fit on load */
fitCanvasToWindow();

/* Expose some debug functions */
window.setPlayerSize = (w,h) => { player.w = w; player.h = h; };

</script>
</body>
</html>
